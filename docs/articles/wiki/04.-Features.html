<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Popular </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Popular ">
    <meta name="generator" content="docfx 2.47.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p>With <a href="https://github.com/ExtendedXmlSerializer/ExtendedXmlSerializer/wiki/03.-The-Basics">the basics</a> out of the way, we can turn our attention to what really makes ExtendedXmlSeralizer tick: its extensible featureset.
As its name suggests, ExtendedXmlSeralizer offers a very flexible (but
albeit new) extension model from which you can build your own
extensions. Pretty much all if not all features you encounter with
ExtendedXmlSeralizer are through extensions. There are quite a few in
our latest version here that showcase this extensibility. The remainder
of this document will showcase the top features of ExtendedXmlSerializer
that are accomplished through its extension system.</p>
<h2 id="popular">Popular</h2>
<p>Here are the features we've noticed users utilizing and mention when talking to us.</p>
<h3 id="optimized-namespaces">Optimized Namespaces</h3>
<p>By default Xml namespaces are emitted on an &quot;as needed&quot; basis:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;List xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:arguments=&quot;Object&quot; xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
      &lt;Capacity&gt;4&lt;/Capacity&gt;
      &lt;Subject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
        &lt;Message&gt;First&lt;/Message&gt;
      &lt;/Subject&gt;
      &lt;Subject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
        &lt;Message&gt;Second&lt;/Message&gt;
      &lt;/Subject&gt;
      &lt;Subject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
        &lt;Message&gt;Third&lt;/Message&gt;
      &lt;/Subject&gt;
    &lt;/List&gt;
</code></pre>
<p>But with one call to the <code>UseOptimizedNamespaces</code> call, namespaces get
placed at the root of the document, thereby reducing document footprint:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().UseOptimizedNamespaces()
                                                                    .Create();
    List&lt;object&gt; subject = new List&lt;object&gt;
                    {
                        new Subject {Message = &quot;First&quot;},
                        new Subject {Message = &quot;Second&quot;},
                        new Subject {Message = &quot;Third&quot;}
                    };
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;List xmlns:ns1=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot; xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:arguments=&quot;Object&quot; xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
      &lt;Capacity&gt;4&lt;/Capacity&gt;
      &lt;ns1:Subject&gt;
        &lt;Message&gt;First&lt;/Message&gt;
      &lt;/ns1:Subject&gt;
      &lt;ns1:Subject&gt;
        &lt;Message&gt;Second&lt;/Message&gt;
      &lt;/ns1:Subject&gt;
      &lt;ns1:Subject&gt;
        &lt;Message&gt;Third&lt;/Message&gt;
      &lt;/ns1:Subject&gt;
    &lt;/List&gt;
</code></pre>
<h3 id="implicit-namespacestyping">Implicit Namespaces/Typing</h3>
<p>If you don't like namespaces at all, you can register types so that they
do not emit namespaces when they are rendered into a document:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Subject))
                                                                    .Create();
    Subject subject = new Subject{ Message = &quot;Hello World!  No namespaces, yay!&quot; };
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;Subject&gt;
      &lt;Message&gt;Hello World!  No namespaces, yay!&lt;/Message&gt;
    &lt;/Subject&gt;
</code></pre>
<h3 id="immutable-classes-and-content">Immutable Classes and Content</h3>
<p>This is a favorite feature of ours in ExtendedXmlSerlializer. The classic serializer only supports
parameterless public constructors. With ExtendedXmlSerializer, you can
use the <code>EnableParameterizedContent</code> call to enable immutable classes.  These are classes
defined by parameterized content in the constructor that by convention have the same name as
the property for which they are meant to assign:</p>
<pre><code class="lang-csharp">    public sealed class ImmutableSubject
    {
        public ImmutableSubject(string message, int number, DateTime time)
        {
            Message = message;
            Number = number;
            Time = time;
        }
    
        public string Message { get; }
        public int Number { get; }
        public DateTime Time { get; }
    }
</code></pre>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableParameterizedContent()
                                                                    .Create();
    ImmutableSubject subject = new ImmutableSubject(&quot;Hello World!&quot;, 123, DateTime.Now);
    string contents = serializer.Serialize(subject);
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;ImmutableSubject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Message&gt;Hello World!&lt;/Message&gt;
      &lt;Number&gt;123&lt;/Number&gt;
      &lt;Time&gt;2018-05-26T11:52:19.7551187-04:00&lt;/Time&gt;
    &lt;/ImmutableSubject&gt;
</code></pre>
<p>Note that we follow the same rules that <a href="https://blog.marcgravell.com/2011/08/automatic-serialization-whats-in-tuple.html">Protobuf.net utilizes for their implementation of same feature</a>:</p>
<p>The rules are:</p>
<ol>
<li>only public fields / properties are considered</li>
<li>any public fields (spit) must be readonly</li>
<li>any public properties must have a get but not a set (on the public API, at least)</li>
<li>there must be exactly one interesting constructor, with parameters that are a case-insensitive match for each field/property in some order (i.e. there must be an obvious 1:1 mapping between members and constructor parameter names)</li>
</ol>
<p>If you have settable properties on your class that are not defined in the constructor, you can use the <code>EnableParameterizedContentWithPropertyAssignments</code> method.</p>
<h2 id="notable">Notable</h2>
<p>Other notable features of the ExtendedXmlSerializer consist of the following:</p>
<h3 id="object-reference-and-circular-reference">Object reference and circular reference</h3>
<p>If you have a class:</p>
<pre><code class="lang-csharp">    public class Person
    {
        public int Id { get; set; }
        public string Name { get; set; }
    
        public Person Boss { get; set; }
    }
    
    public class Company
    {
        public List&lt;Person&gt; Employees { get; set; }
    }
</code></pre>
<p>then you create object with circular reference, like this:</p>
<pre><code class="lang-csharp">    Person boss = new Person {Id = 1, Name = &quot;John&quot;};
    boss.Boss = boss; //himself boss
    Person worker = new Person {Id = 2, Name = &quot;Oliver&quot;};
    worker.Boss = boss;
    Company obj = new Company
    {
        Employees = new List&lt;Person&gt;
        {
            worker,
            boss
        }
    };
</code></pre>
<p>You must configure Person class as reference object:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().ConfigureType&lt;Person&gt;()
                                                                    .EnableReferences(p =&gt; p.Id)
                                                                    .Create();
</code></pre>
<p>Output XML will look like this:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;Company xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.ObjectReference;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Employees&gt;
        &lt;Capacity&gt;4&lt;/Capacity&gt;
        &lt;Person Id=&quot;2&quot;&gt;
          &lt;Name&gt;Oliver&lt;/Name&gt;
          &lt;Boss Id=&quot;1&quot;&gt;
            &lt;Name&gt;John&lt;/Name&gt;
            &lt;Boss xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:entity=&quot;1&quot; /&gt;
          &lt;/Boss&gt;
        &lt;/Person&gt;
        &lt;Person xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:entity=&quot;1&quot; /&gt;
      &lt;/Employees&gt;
    &lt;/Company&gt;
</code></pre>
<h4 id="how-circular-references-are-handled">How Circular References Are Handled</h4>
<p>Have you ever used a serializer and discovered there are three &quot;states&quot; for circular references?  Usually classified by an enumeration (the close cousin of <a href="https://softwareengineering.stackexchange.com/questions/147977/is-it-wrong-to-use-a-boolean-parameter-to-determine-behavior">booleanitis</a>):</p>
<ul>
<li>Ignore (<a href="https://www.youtube.com/watch?v=MCn9lL94sxQ">wat?</a>)</li>
<li>Handle</li>
<li>Throw</li>
</ul>
<p>The first one is a head-scratcher.  Since we are talking about a perpetual, endless loop, why would you want to enable this scenario without fail?  Or,if you are going to ignore this property altogether, why provide a special case for a configuration that should be allowed for <em>every</em> member (ala <code>IgnoreMemberAttributre</code> or our <code>Ignore</code> call)?</p>
<p>Upon analysis there are only two states here: throw or collect the data.  By default, ExtendedXmlSerializer throws as it is the most performant and also allows the user to know that something special is occurring in their object graph.</p>
<p>The use of <code>EnableReferences</code> allows them to collect their object graph and continue meaning serialization.</p>
<p>More information around this process can be found here:
<a href="https://github.com/wojtpl2/ExtendedXmlSerializer/issues/202">https://github.com/wojtpl2/ExtendedXmlSerializer/issues/202</a></p>
<h3 id="property-encryption">Property Encryption</h3>
<p>If you have a class with a property that needs to be encrypted:</p>
<pre><code class="lang-csharp">    public class Person
    {
        public string Name { get; set; }
        public string Password { get; set; }
    }
</code></pre>
<p>You must implement interface <code>IEncryption</code>. For example, it will show the
Base64 encoding, but in the real world better to use something safer,
eg. RSA.:</p>
<pre><code class="lang-csharp">    public class CustomEncryption : IEncryption
    {
        public string Parse(string data)
            =&gt; Encoding.UTF8.GetString(Convert.FromBase64String(data));
    
        public string Format(string instance)
            =&gt; Convert.ToBase64String(Encoding.UTF8.GetBytes(instance));
    }
</code></pre>
<p>Then, you have to specify which properties are to be encrypted and
register your <code>IEncryption</code> implementation.</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().UseEncryptionAlgorithm(new CustomEncryption())
                                                                    .ConfigureType&lt;Person&gt;()
                                                                    .Member(p =&gt; p.Password)
                                                                    .Encrypt()
                                                                    .Create();
</code></pre>
<h3 id="custom-conversion">Custom Conversion</h3>
<p>ExtendedXmlSerializer does a pretty decent job (if we do say so
ourselves) of composing and decomposing objects, but if you happen to
have a type that you want serialized in a certain way, and this type can
be destructured into a string, then you can register a custom converter
for it.</p>
<p>Using the following:</p>
<pre><code class="lang-csharp">    public sealed class CustomStructConverter : IConverter&lt;CustomStruct&gt;
    {
        public static CustomStructConverter Default { get; } = new CustomStructConverter();
        CustomStructConverter() {}
    
        public bool IsSatisfiedBy(TypeInfo parameter) =&gt; typeof(CustomStruct).GetTypeInfo()
                                                                             .IsAssignableFrom(parameter);
    
        public CustomStruct Parse(string data) =&gt;
            int.TryParse(data, out int number) ? new CustomStruct(number) : CustomStruct.Default;
    
        public string Format(CustomStruct instance) =&gt; instance.Number.ToString();
    }
    
    public struct CustomStruct
    {
        public static CustomStruct Default { get; } = new CustomStruct(6776);
    
        public CustomStruct(int number)
        {
            Number = number;
        }
        public int Number { get; }
    }
</code></pre>
<p>Register the converter:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().Register(CustomStructConverter.Default).Create();
    CustomStruct subject = new CustomStruct(123);
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;CustomStruct xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;123&lt;/CustomStruct&gt;
</code></pre>
<h3 id="auto-formatting-attributes">Auto-Formatting (Attributes)</h3>
<p>The default behavior for emitting data in an Xml document is to use
elements, which can be a little chatty and verbose:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().UseOptimizedNamespaces()
                                                                    .Create();
    List&lt;object&gt; subject = new List&lt;object&gt;
                    {
                        new Subject {Message = &quot;First&quot;},
                        new Subject {Message = &quot;Second&quot;},
                        new Subject {Message = &quot;Third&quot;}
                    };
    string contents = serializer.Serialize(subject);
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;SubjectWithThreeProperties xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Number&gt;123&lt;/Number&gt;
      &lt;Message&gt;Hello World!&lt;/Message&gt;
      &lt;Time&gt;2018-05-26T11:52:19.4981212-04:00&lt;/Time&gt;
    &lt;/SubjectWithThreeProperties&gt;
</code></pre>
<p>Making use of the <code>UseAutoFormatting</code> call will enable all types that have
a registered IConverter (convert to string and back) to emit as
attributes:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;SubjectWithThreeProperties Number=&quot;123&quot; Message=&quot;Hello World!&quot; Time=&quot;2018-05-26T11:52:19.4981212-04:00&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot; /&gt;
</code></pre>
<h3 id="verbatim-content-cdata">Verbatim Content (CDATA)</h3>
<p>If you have an element with a member that can hold lots of data, or data
that has illegal characters, you configure it to be a verbatim field and
it will emit a CDATA section around it:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().Type&lt;Subject&gt;()
                                                                    .Member(x =&gt; x.Message)
                                                                    .Verbatim()
                                                                    .Create();
    Subject subject = new Subject {Message = @&quot;&lt;{&quot;&quot;Ilegal characters and such&quot;&quot;}&gt;&quot;};
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;Subject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Message&gt;&lt;![CDATA[&lt;{&quot;Ilegal characters and such&quot;}&gt;]]&gt;&lt;/Message&gt;
    &lt;/Subject&gt;
</code></pre>
<p>You can also denote these fields with an attribute and get the same
functionality:</p>
<pre><code class="lang-csharp">    public sealed class VerbatimSubject
    {
        [Verbatim]
        public string Message { get; set; }
    }
</code></pre>
<h3 id="private-constructors">Private Constructors</h3>
<p>One of the limitations of the classic XmlSerializer is that it does not
support private constructors, but ExtendedXmlSerializer does via its
EnableAllConstructors call:</p>
<pre><code class="lang-csharp">    public sealed class SubjectByFactory
    {
        public static SubjectByFactory Create(string message) =&gt; new SubjectByFactory(message);
    
        SubjectByFactory() : this(null) {} // Used by serializer.
    
        SubjectByFactory(string message) =&gt; Message = message;
    
        public string Message { get; set; }
    }
</code></pre>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableAllConstructors()
                                                                    .Create();
    SubjectByFactory subject = SubjectByFactory.Create(&quot;Hello World!&quot;);
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;SubjectByFactory xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Message&gt;Hello World!&lt;/Message&gt;
    &lt;/SubjectByFactory&gt;
</code></pre>
<h3 id="tuples">Tuples</h3>
<p>By enabling parameterized content, it opens up a lot of possibilities,
like being able to serialize Tuples. Of course, serializable Tuples were
introduced recently with the latest version of C#. Here, however, you
can couple this with our member-naming funtionality and provide better
naming for your tuple properties:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableParameterizedContent()
                                                                    .Type&lt;Tuple&lt;string&gt;&gt;()
                                                                    .Member(x =&gt; x.Item1)
                                                                    .Name(&quot;Message&quot;)
                                                                    .Create();
    Tuple&lt;string&gt; subject = Tuple.Create(&quot;Hello World!&quot;);
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;Tuple xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:arguments=&quot;string&quot; xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
      &lt;Message&gt;Hello World!&lt;/Message&gt;
    &lt;/Tuple&gt;
</code></pre>
<h2 id="experimental">Experimental</h2>
<p>These features are experimental, but please try them out and let us know what you think!</p>
<h3 id="xaml-ness-attached-properties">Xaml-ness: Attached Properties</h3>
<p>We went ahead and got a little cute with v2 of ExtendedXmlSerializer,
adding support for Attached Properties on objects in your serialized
object graph. But instead of constraining it to objects that inherit
from <code>DependencyObject</code>, <em>every</em> object can benefit from it. Check it out:</p>
<pre><code class="lang-csharp">    sealed class NameProperty : ReferenceProperty&lt;Subject, string&gt;
    {
        public const string DefaultMessage = &quot;The Name Has Not Been Set&quot;;
    
        public static NameProperty Default { get; } = new NameProperty();
        NameProperty() : base(() =&gt; Default, x =&gt; DefaultMessage) {}
    }
    
    sealed class NumberProperty : StructureProperty&lt;Subject, int&gt;
    {
        public const int DefaultValue = 123;
    
        public static NumberProperty Default { get; } = new NumberProperty();
        NumberProperty() : base(() =&gt; Default, x =&gt; DefaultValue) {}
    }
</code></pre>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer()
                                        .EnableAttachedProperties(NameProperty.Default, NumberProperty.Default)
                                        .Create();
    Subject subject = new Subject {Message = &quot;Hello World!&quot;};
    subject.Set(NameProperty.Default, &quot;Hello World from Attached Properties!&quot;);
    subject.Set(NumberProperty.Default, 123);
    
    string contents = serializer.Serialize(subject);
    // ...
</code></pre>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;Subject xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Message&gt;Hello World!&lt;/Message&gt;
      &lt;NameProperty.Default&gt;Hello World from Attached Properties!&lt;/NameProperty.Default&gt;
      &lt;NumberProperty.Default&gt;123&lt;/NumberProperty.Default&gt;
    &lt;/Subject&gt;
</code></pre>
<h3 id="xaml-ness-markup-extensions">Xaml-ness: Markup Extensions</h3>
<p>Saving the most novel feature for last, we have experimental support for one of
Xaml's greatest features, Markup Extensions:</p>
<pre><code class="lang-csharp">    sealed class Extension : IMarkupExtension
    {
        const string Message = &quot;Hello World from Markup Extension! Your message is: &quot;, None = &quot;N/A&quot;;
    
        readonly string _message;
    
        public Extension() : this(None) {}
    
        public Extension(string message)
        {
            _message = message;
        }
    
        public object ProvideValue(IServiceProvider serviceProvider) =&gt; string.Concat(Message, _message);
    }
</code></pre>
<pre><code class="lang-csharp">    string contents =
        @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
            &lt;Subject xmlns=&quot;&quot;clr-namespace:ExtendedXmlSerializer.Samples.Extensibility;assembly=ExtendedXmlSerializer.Samples&quot;&quot;
            Message=&quot;&quot;{Extension 'PRETTY COOL HUH!!!'}&quot;&quot; /&gt;&quot;;
    IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableMarkupExtensions()
                                                                    .Create();
    Subject subject = serializer.Deserialize&lt;Subject&gt;(contents);
    Console.WriteLine(subject.Message); // &quot;Hello World from Markup Extension! Your message is: PRETTY COOL HUH!!!&quot;
</code></pre>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/ExtendedXmlSerializer/ExtendedXmlSerializer.wiki/blob/master/04.-Features.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
