<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Serialization of dictionary </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Serialization of dictionary ">
    <meta name="generator" content="docfx 2.47.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h2 id="serialization-of-dictionary">Serialization of dictionary</h2>

<p>You can serialize generic dictionary, that can store any type.</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public Dictionary&lt;int, string&gt; Dictionary { get; set; }
    }
</code></pre>
<pre><code class="lang-csharp">    TestClass obj = new TestClass
    {
        Dictionary = new Dictionary&lt;int, string&gt;
        {
            {1, &quot;First&quot;},
            {2, &quot;Second&quot;},
            {3, &quot;Other&quot;},
        }
    };
</code></pre>
<p>Output XML will look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Dictianary;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Dictionary&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;1&lt;/Key&gt;
          &lt;Value&gt;First&lt;/Value&gt;
        &lt;/Item&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;2&lt;/Key&gt;
          &lt;Value&gt;Second&lt;/Value&gt;
        &lt;/Item&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;3&lt;/Key&gt;
          &lt;Value&gt;Other&lt;/Value&gt;
        &lt;/Item&gt;
      &lt;/Dictionary&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>If you use <code>UseOptimizedNamespaces</code> function xml will look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:sys=&quot;https://extendedxmlserializer.github.io/system&quot; xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Dictianary;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Dictionary&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;1&lt;/Key&gt;
          &lt;Value&gt;First&lt;/Value&gt;
        &lt;/sys:Item&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;2&lt;/Key&gt;
          &lt;Value&gt;Second&lt;/Value&gt;
        &lt;/sys:Item&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;3&lt;/Key&gt;
          &lt;Value&gt;Other&lt;/Value&gt;
        &lt;/sys:Item&gt;
      &lt;/Dictionary&gt;
    &lt;/TestClass&gt;
</code></pre>
<h2 id="custom-serialization">Custom serialization</h2>
<p>If your class has to be serialized in a non-standard way:</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public TestClass(string paramStr, int paramInt)
        {
            PropStr = paramStr;
            PropInt = paramInt;
        }
    
        public string PropStr { get; private set; }
        public int PropInt { get; private set; }
    }
</code></pre>
<p>You must create custom serializer:</p>
<pre><code class="lang-csharp">    public class TestClassSerializer : IExtendedXmlCustomSerializer&lt;TestClass&gt;
    {
        public TestClass Deserialize(XElement element)
        {
            XElement xElement = element.Member(&quot;String&quot;);
            XElement xElement1 = element.Member(&quot;Int&quot;);
            if (xElement != null &amp;&amp; xElement1 != null)
            {
                string strValue = xElement.Value;
    
                int intValue = Convert.ToInt32(xElement1.Value);
                return new TestClass(strValue, intValue);
            }
            throw new InvalidOperationException(&quot;Invalid xml for class TestClassWithSerializer&quot;);
        }
    
        public void Serializer(XmlWriter writer, TestClass obj)
        {
            writer.WriteElementString(&quot;String&quot;, obj.PropStr);
            writer.WriteElementString(&quot;Int&quot;, obj.PropInt.ToString(CultureInfo.InvariantCulture));
        }
    }
</code></pre>
<p>Then, you have to add custom serializer to configuration of TestClass:</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().Type&lt;TestClass&gt;()
                                                                    .CustomSerializer(new TestClassSerializer())
                                                                    .Create();
</code></pre>
<h2 id="migrate-old-version-of-xml">Migrate Old Version of XML</h2>
<p>In standard XMLSerializer you can't deserialize XML in case you change
model. In ExtendedXMLSerializer you can create migrator for each class
separately. E.g.: If you have big class, that uses small class and this
small class will be changed you can create migrator only for this small
class. You don't have to modify whole big XML. Now I will show you a
simple example.</p>
<p>If you had a class:</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Type { get; set; }
    }
</code></pre>
<p>and generated XML look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns=&quot;clr-namespace:ExtendedXmlSerialization.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Type&gt;Type&lt;/Type&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>Then you renamed property:</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
</code></pre>
<p>and generated XML look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:version=&quot;1&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerialization.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Name&gt;Type&lt;/Name&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>Then, you added new property and you wanted to calculate a new value during deserialization.</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Value { get; set; }
    }
</code></pre>
<p>and new XML should look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:version=&quot;2&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Name&gt;Type&lt;/Name&gt;
      &lt;Value&gt;Calculated&lt;/Value&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>You can migrate (read) old version of XML using migrations:</p>
<pre><code class="lang-csharp">    public class TestClassMigrations : IEnumerable&lt;Action&lt;XElement&gt;&gt;
    {
        public static void MigrationV0(XElement node)
        {
            XElement typeElement = node.Member(&quot;Type&quot;);
            // Add new node
            node.Add(new XElement(&quot;Name&quot;, typeElement.Value));
            // Remove old node
            typeElement.Remove();
        }
    
        public static void MigrationV1(XElement node)
        {
            // Add new node
            node.Add(new XElement(&quot;Value&quot;, &quot;Calculated&quot;));
        }
    
        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
    
        public IEnumerator&lt;Action&lt;XElement&gt;&gt; GetEnumerator()
        {
            yield return MigrationV0;
            yield return MigrationV1;
        }
    }
</code></pre>
<p>Then, you must register your <code>TestClassMigrations</code> class in configuration</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().ConfigureType&lt;TestClass&gt;()
                                                                    .AddMigration(new TestClassMigrations())
                                                                    .Create();
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
